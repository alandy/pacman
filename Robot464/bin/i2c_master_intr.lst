*** EVALUATION ***
ANSI-C/cC++ Compiler for HC12 V-5.0.38 Build 9056, Feb 26 2009

    1:                                                                                                                 /** ###################################################################
    2:  **     THIS BEAN MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
    3:  **     Filename  : I2C1.C
    4:  **     Project   : nick
    5:  **     Processor : MC9S12DP512BCPV
    6:  **     Beantype  : InternalI2C
    7:  **     Version   : Bean 01.200, Driver 01.18, CPU db: 2.87.357
    8:  **     Compiler  : CodeWarrior HC12 C Compiler
    9:  **     Date/Time : 9/25/2009, 4:27 PM
   10:  **     Abstract  :
   11:  **          This bean encapsulates the internal I2C communication 
   12:  **          interface. The implementation of the interface is based 
   13:  **          on the Philips I2C-bus specification version 2.0. 
   14:  **          Interface features:
   15:  **          MASTER mode
   16:  **            - Multi master communication
   17:  **            - The combined format of communication possible 
   18:  **              (see "Automatic stop condition" property)
   19:  **            - 7-bit slave addressing (10-bit addressing can be made as well)
   20:  **            - Acknowledge polling provided
   21:  **            - No wait state initiated when a slave device holds the SCL line low
   22:  **            - Holding of the SCL line low by slave device recognized as 'not available bus'
   23:  **            - Invalid start/stop condition detection provided
   24:  **          SLAVE mode
   25:  **            - 7-bit slave addressing
   26:  **            - General call address detection provided
   27:  **     Settings  :
   28:  **         Serial channel              : IIC
   29:  **
   30:  **         Protocol
   31:  **             Mode                    : MASTER
   32:  **             Auto stop condition     : yes
   33:  **             SCL frequency           : 100 kHz
   34:  **
   35:  **         Initialization
   36:  **
   37:  **             Target slave address    : 8
   38:  **             Bean function           : Enabled
   39:  **             Events                  : Enabled
   40:  **
   41:  **         Registers
   42:  **             Input buffer            : IBDR      [228]
   43:  **             Output buffer           : IBDR      [228]
   44:  **             Control register        : IBCR      [226]
   45:  **             Status register         : IBSR      [227]
   46:  **             Baud setting reg.       : IBFD      [225]
   47:  **             Address register        : IBAD      [224]
   48:  **
   49:  **         Interrupt
   50:  **             Vector name             : Viic
   51:  **             Priority                : 1
   52:  **
   53:  **         Used pins                   :
   54:  **       ----------------------------------------------------------
   55:  **            Function    | On package |    Name
   56:  **       ----------------------------------------------------------
   57:  **              SDA       |     99     |  PJ6_RxCAN4_SDA_RxCAN0_KWJ6
   58:  **              SCL       |     98     |  PJ7_TxCAN4_SCL_TxCAN0_KWJ7
   59:  **       ----------------------------------------------------------
   60:  **     Contents  :
   61:  **         Enable          - byte I2C1_Enable(void);
   62:  **         Disable         - byte I2C1_Disable(void);
   63:  **         EnableEvent     - byte I2C1_EnableEvent(void);
   64:  **         DisableEvent    - byte I2C1_DisableEvent(void);
   65:  **         SendChar        - byte I2C1_SendChar(byte Chr);
   66:  **         RecvChar        - byte I2C1_RecvChar(byte *Chr);
   67:  **         SendBlock       - byte I2C1_SendBlock(void* Ptr, word Siz, word *Snt);
   68:  **         RecvBlock       - byte I2C1_RecvBlock(void* Ptr, word Siz, word *Rcv);
   69:  **         GetCharsInTxBuf - word I2C1_GetCharsInTxBuf(void);
   70:  **         SelectSlave     - byte I2C1_SelectSlave(byte Slv);
   71:  **         GetCharsInRxBuf - word I2C1_GetCharsInRxBuf(void);
   72:  **         GetMode         - bool I2C1_GetMode(void);
   73:  **         CheckBus        - byte I2C1_CheckBus(void);
   74:  **
   75:  **     (c) Copyright UNIS, a.s. 1997-2008
   76:  **     UNIS, a.s.
   77:  **     Jundrovska 33
   78:  **     624 00 Brno
   79:  **     Czech Republic
   80:  **     http      : www.processorexpert.com
   81:  **     mail      : info@processorexpert.com
   82:  ** ###################################################################*/
   83:  
   84:  
   85:  /* MODULE I2C1. */
   86:  
   87:  //#pragma MESSAGE DISABLE C4002          /* Disable warning C4002 "Result not used" */
   88:  
   89:  //#include "Events.h"
   90:  #include <mc9s12dp512.h>
   91:  //#include "I2C1.h"
   92:  #include "i2c_master_intr.h"
   93:  
   94:  
   95:  //#pragma DATA_SEG I2C1_DATA
   96:  //#pragma CODE_SEG I2C1_CODE
   97:  /*SerFlag bits*/
   98:  #define OVERRUN_ERR      1             /* Overrun error flag bit   */
   99:  #define WAIT_RX_CHAR     2             /* Wait for received char. flag bit (Master)  */
  100:  #define CHAR_IN_TX       4             /* Char is in TX buffer (Master)    */
  101:  #define CHAR_IN_RX       8             /* Char is in RX buffer     */
  102:  #define FULL_TX          16            /* Full transmit buffer     */
  103:  #define BUSY             32            /* Communication is in progress (Master) */
  104:  #define FULL_RX          64            /* Full receive buffer      */
  105:  #define MSxSL            128           /* Master x Slave flag bit  */
  106:  
  107:  static unsigned char EnUser;                    /* Enable/Disable device */
  108:  volatile unsigned char I2C1_EnEvent;            /* Enable/Disable events */
  109:  static unsigned char I2C1_SlaveAddr;            /* Variable for Slave address */
  110:  static unsigned short InpLenM;                   /* Length of input bufer's content */
  111:  static unsigned char *InpPtrM;                  /* Pointer to input buffer for Master mode */
  112:  static unsigned short OutLenM;                   /* Length of output bufer's content */
  113:  static unsigned char *OutPtrM;                  /* Pointer to output buffer for Master mode */
  114:  volatile unsigned short I2C1_SndRcvTemp;         /* Temporary variable for SendChar (RecvChar) when they call SendBlock (RecvBlock) */
  115:  static unsigned char ChrTemp;                   /* Temporary variable for SendChar method */
  116:  volatile unsigned char I2C1_SerFlag;            /* Flags for serial communication */
  117:                                         /* Bits: 0 - OverRun error */
  118:                                         /*       1 - Wait for received char. flag bit (Master) */
  119:                                         /*       2 - Char is in TX buffer (Master) */
  120:                                         /*       3 - Char in RX buffer */
  121:                                         /*       4 - Full TX buffer */
  122:                                         /*       5 - Running int from TX */
  123:                                         /*       6 - Full RX buffer */
  124:                                         /*       7 - Master x Slave */
  125:                                         
  126:  unsigned char newI2cData = 0; //external signal
  127:  unsigned char I2cTransDone = 0; //external signal
  128:                                         
  129:  
  130:  void I2C1_OnReceiveData(void);
  131:  void I2C1_OnTransmitData(void);
  132:  void I2C1_OnByteTransfer(void);
  133:  void I2C1_OnArbitLost(void);
  134:  void I2C1_OnNACK(void);
  135:  
  136:  //#pragma MESSAGE DISABLE C4002 /* WARNING C4002: Result not used is ignored */
  137:  
  138:  /*
  139:  ** ===================================================================
  140:  **     Method      :  I2C1_Interrupt (bean InternalI2C)
  141:  **
  142:  **     Description :
  143:  **         The method services the interrupt of the selected peripheral(s)
  144:  **         and eventually invokes the beans event(s).
  145:  **         This method is internal. It is used by Processor Expert only.
  146:  ** ===================================================================
  147:  */
  148:  #define RXAK 1
  149:  #define SRW  4
  150:  #define IBAL 16
  151:  #define IAAS 64
  152:  
  153:  #define ON_ARBIT_LOST 1
  154:  #define ON_FULL_RX    2
  155:  #define ON_RX_CHAR    4
  156:  #define ON_FREE_TX    8
  157:  #define ON_TX_CHAR    16
  158:  #define ON_OVERRUN    32
  159:  #define ON_TX_EMPTY   64
  160:  
  161:  //#pragma CODE_SEG __NEAR_SEG NON_BANKED
  162:  
  163:  interrupt 31 void i2c_isr(void)
  164:  {
*** EVALUATION ***

Function: i2c_isr
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  165:    unsigned char Status = IBSR;                  /* Safe status register */
  0000 d600         [3]     LDAB  _IBSR
  0002 37           [2]     PSHB  
  166:    //LED_BLUE1 ^= 1;
  167:    asm sei
  0003 1410         [1]     SEI   
  168:    IBSR_IBIF = 1;                       /* Clear interrupt flag */
  0005 4c0002       [4]     BSET  _IBSR,#2
  169:    if(IBCR_MS_SL){                      /* Is device in master mode? */
  0008 4e002003     [4]     BRSET _IBCR,#32,*+7 ;abs = 000f
  000c 060000       [3]     JMP   i2c_isr:0x00a2
  170:      if (I2C1_EnEvent) {
  000f f60000       [3]     LDAB  I2C1_EnEvent
  0012 2703         [3/1]   BEQ   *+5 ;abs = 0017
  171:        I2C1_OnByteTransfer();           /* Invoke OnByteTransfer event */
  0014 160000       [4]     JSR   I2C1_OnByteTransfer
  172:      }
  173:      if(IBCR_TX_RX){                    /* Is device in Tx mode? */
  0017 4f001054     [4]     BRCLR _IBCR,#16,*+88 ;abs = 006f
  174:        if(Status & RXAK) {              /* NACK received? */
  001b 0f800113     [4]     BRCLR 0,SP,#1,*+23 ;abs = 0032
  175:          IBCR_MS_SL = 0;                /* Switch device to slave mode (stop signal sent) */
  001f 4d0020       [4]     BCLR  _IBCR,#32
  176:          IBCR_TX_RX = 0;                /* Switch to Rx mode */
  0022 4d0010       [4]     BCLR  _IBCR,#16
  177:          OutLenM = 0;                   /* No character for sending */
  0025 160000       [4]     JSR   i2c_isr:0x00b7
  178:          InpLenM = 0;                   /* No character for reception */
  179:          I2C1_SerFlag &= ~(CHAR_IN_TX|WAIT_RX_CHAR|BUSY); /* No character for sending or reception*/
  180:          if (I2C1_EnEvent) {
  0028 f60000       [3]     LDAB  I2C1_EnEvent
  002b 272f         [3/1]   BEQ   *+49 ;abs = 005c
  181:            // __DI();                     /* Disable maskable interrupts */
  182:            I2C1_OnNACK();               /* Invoke OnNACK event */
  002d 160000       [4]     JSR   I2C1_OnNACK
  0030 202a         [3]     BRA   *+44 ;abs = 005c
  183:          }
  184:        }
  185:        else {
  186:          if(OutLenM) {                  /* Is any char. for transmitting? */
  0032 fe0000       [3]     LDX   OutLenM
  0035 2710         [3/1]   BEQ   *+18 ;abs = 0047
  187:            OutLenM--;                   /* Decrease number of chars for the transmit */
  0037 09           [1]     DEX   
  0038 7e0000       [3]     STX   OutLenM
  188:            IBDR = *(OutPtrM)++;         /* Send character */
  003b fe0000       [3]     LDX   OutPtrM
  003e e630         [3]     LDAB  1,X+
  0040 7e0000       [3]     STX   OutPtrM
  0043 5b00         [2]     STAB  _IBDR
  189:          }
  0045 206c         [3]     BRA   *+110 ;abs = 00b3
  190:          else {
  191:            if(InpLenM) {                /* Is any char. for reception? */
  0047 fc0000       [3]     LDD   InpLenM
  004a 2712         [3/1]   BEQ   *+20 ;abs = 005e
  192:              if(InpLenM == 1) {         /* If only one char to receive */
  004c 042405       [3]     DBNE  D,*+8 ;abs = 0054
  193:                IBCR_TXAK = 1;           /* then transmit ACK disable */
  004f 4c0008       [4]     BSET  _IBCR,#8
  194:              }
  0052 2003         [3]     BRA   *+5 ;abs = 0057
  195:              else {  //may need to take these comments out
  196:                IBCR_TXAK = 0;           /* else transmit ACK anable */
  0054 4d0008       [4]     BCLR  _IBCR,#8
  197:              }
  198:              IBCR_TX_RX = 0;            /* Switch to Rx mode */
  0057 4d0010       [4]     BCLR  _IBCR,#16
  199:              (void)IBDR;                /* Dummy read character */
  005a d600         [3]     LDAB  _IBDR
  200:            }
  005c 2055         [3]     BRA   *+87 ;abs = 00b3
  201:            else {
  202:              I2C1_SerFlag &= ~BUSY;     /* Clear flag "busy" */
  005e 1d000020     [4]     BCLR  I2C1_SerFlag,#32
  203:              //IBCR_MS_SL = 0;            /* Switch device to slave mode (stop signal sent) */
  204:              //IBCR_TX_RX = 0;            /* Switch to Rx mode */
  205:      //added for compass
  206:              IBCR_RSTA = 1;// repeated start
  0062 4c0004       [4]     BSET  _IBCR,#4
  207:      //end        
  208:              if (I2C1_EnEvent) {
  0065 f60000       [3]     LDAB  I2C1_EnEvent
  0068 2749         [3/1]   BEQ   *+75 ;abs = 00b3
  209:                // __DI();                 /* Disable maskable interrupts */
  210:                I2C1_OnTransmitData();   /* Invoke OnTransmitData event */
  006a 160000       [4]     JSR   I2C1_OnTransmitData
  006d 2044         [3]     BRA   *+70 ;abs = 00b3
  211:              }
  212:            }
  213:          }
  214:        }
  215:      }
  216:      else {
  217:        InpLenM--;                       /* Decrease number of chars for the receive */
  006f fe0000       [3]     LDX   InpLenM
  0072 09           [1]     DEX   
  0073 7e0000       [3]     STX   InpLenM
  218:        if(InpLenM) {                    /* Is any char. for reception? */
  0076 2708         [3/1]   BEQ   *+10 ;abs = 0080
  219:          if(InpLenM == 1) {
  0078 04250e       [3]     DBNE  X,*+17 ;abs = 0089
  220:            IBCR_TXAK = 1;               /* Transmit ACK disable */
  007b 4c0008       [4]     BSET  _IBCR,#8
  007e 2009         [3]     BRA   *+11 ;abs = 0089
  221:          }
  222:        }
  223:        else {
  224:          IBCR_MS_SL = 0;                /* If no, switch device to slave mode (stop signal sent) */
  0080 4d0020       [4]     BCLR  _IBCR,#32
  225:          IBCR_TX_RX = 0; ///////may not need this
  0083 4d0010       [4]     BCLR  _IBCR,#16
  226:          IBCR_TXAK = 0;                 /* Transmit ACK enable */
  0086 4d0008       [4]     BCLR  _IBCR,#8
  227:        }
  228:        *(InpPtrM)++ = IBDR;             /* Receive character */
  0089 fe0000       [3]     LDX   InpPtrM
  008c d600         [3]     LDAB  _IBDR
  008e 6b30         [2]     STAB  1,X+
  0090 7e0000       [3]     STX   InpPtrM
  229:        if(!InpLenM) {                   /* Is any char. for reception? */
  0093 fc0000       [3]     LDD   InpLenM
  0096 261b         [3/1]   BNE   *+29 ;abs = 00b3
  230:          if (I2C1_EnEvent) {
  0098 f60000       [3]     LDAB  I2C1_EnEvent
  009b 2716         [3/1]   BEQ   *+24 ;abs = 00b3
  231:           //  __DI();                     /* Disable maskable interrupts */
  232:            I2C1_OnReceiveData();        /* Invoke OnReceiveData event */
  009d 160000       [4]     JSR   I2C1_OnReceiveData
  00a0 2011         [3]     BRA   *+19 ;abs = 00b3
  233:          }
  234:        }
  235:      }
  236:    }
  237:    else {
  238:      if(Status & IBAL) {                /* Arbitration lost? */
  00a2 0f80100d     [4]     BRCLR 0,SP,#16,*+17 ;abs = 00b3
  239:        OutLenM = 0;                     /* No character for sending */
  00a6 070f         [4]     BSR   *+17 ;abs = 00b7
  240:        InpLenM = 0;                     /* No character for reception */
  241:        I2C1_SerFlag &= ~(CHAR_IN_TX|WAIT_RX_CHAR|BUSY); /* No character for sending or reception*/
  242:        IBCR_TX_RX = 0;                  /* Switch to Rx mode */
  00a8 4d0010       [4]     BCLR  _IBCR,#16
  243:        if (I2C1_EnEvent) {
  00ab f60000       [3]     LDAB  I2C1_EnEvent
  00ae 2703         [3/1]   BEQ   *+5 ;abs = 00b3
  244:         //  __DI();                       /* Disable maskable interrupts */
  245:          I2C1_OnArbitLost();            /* Invoke OnArbitLost event */
  00b0 160000       [4]     JSR   I2C1_OnArbitLost
  246:        }
  247:      }
  248:    }
  249:    asm cli
  00b3 10ef         [1]     CLI   
  250:  }
  00b5 32           [3]     PULA  
  00b6 0b           [8]     RTI   
  00b7 c7           [1]     CLRB  
  00b8 87           [1]     CLRA  
  00b9 7c0000       [3]     STD   OutLenM
  00bc 7c0000       [3]     STD   InpLenM
  00bf 1d000026     [4]     BCLR  I2C1_SerFlag,#38
  00c3 3d           [5]     RTS   
  251:  
  252:  //#pragma CODE_SEG I2C1_CODE
  253:  /*
  254:  ** ===================================================================
  255:  **     Method      :  I2C1_Enable (bean InternalI2C)
  256:  **
  257:  **     Description :
  258:  **         Enables I2C bean. Events may be generated
  259:  **         ("DisableEvent"/"EnableEvent").
  260:  **     Parameters  : None
  261:  **     Returns     :
  262:  **         ---             - Error code, possible codes:
  263:  **                           ERR_OK - OK
  264:  **                           ERR_SPEED - This device does not work in
  265:  **                           the active speed mode
  266:  ** ===================================================================
  267:  */
  268:  unsigned char I2C1_Enable(void)
  269:  {
*** EVALUATION ***

Function: I2C1_Enable
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  270:    if (!EnUser) {                       /* Is the device disabled by user? */
  0000 f60000       [3]     LDAB  EnUser
  0003 260f         [3/1]   BNE   *+17 ;abs = 0014
  271:      EnUser = 1;                     /* If yes then set the flag "device enabled" */
  0005 ccc001       [2]     LDD   #49153
  0008 7b0000       [3]     STAB  EnUser
  272:      I2C1_SerFlag &= ~127;              /* Clear the status variable */
  000b 1d00007f     [4]     BCLR  I2C1_SerFlag,#127
  273:      IBCR_IBEN = 1;                     /* Enable device */
  000f 4c0080       [4]     BSET  _IBCR,#128
  274:      /* IBCR: IBEN=1,IBIE=1,MS_SL=0,TX_RX=0,TXAK=0,RSTA=0,??=0,IBSWAI=0 */
  275:      IBCR = 192;                        /* Control register settings */
  0012 5a00         [2]     STAA  _IBCR
  276:    }
  277:    return ERR_OK;                       /* OK */
  0014 c7           [1]     CLRB  
  278:  }
  0015 3d           [5]     RTS   
  279:  
  280:  /*
  281:  ** ===================================================================
  282:  **     Method      :  I2C1_Disable (bean InternalI2C)
  283:  **
  284:  **     Description :
  285:  **         Disables I2C bean. No events will be generated.
  286:  **     Parameters  : None
  287:  **     Returns     :
  288:  **         ---             - Error code, possible codes:
  289:  **                           ERR_OK - OK
  290:  **                           ERR_SPEED - This device does not work in
  291:  **                           the active speed mode
  292:  ** ===================================================================
  293:  */
  294:  unsigned char I2C1_Disable(void)
  295:  {
*** EVALUATION ***

Function: I2C1_Disable
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  296:    if (EnUser) {                        /* Is the device enabled by user? */
  0000 f60000       [3]     LDAB  EnUser
  0003 2706         [3/1]   BEQ   *+8 ;abs = 000b
  297:      EnUser = 0;                    /* If yes then set the flag "device disabled" */
  0005 790000       [3]     CLR   EnUser
  298:      /* IBCR: IBEN=0,IBIE=0,MS_SL=0,TX_RX=0,TXAK=0,RSTA=0,??=0,IBSWAI=0 */
  299:      IBCR = 0;                          /* Disable device */
  0008 790000       [3]     CLR   _IBCR
  300:    }
  301:    return ERR_OK;                       /* OK */
  000b c7           [1]     CLRB  
  302:  }
  000c 3d           [5]     RTS   
  303:  
  304:  /*
  305:  ** ===================================================================
  306:  **     Method      :  I2C1_EnableEvent (bean InternalI2C)
  307:  **
  308:  **     Description :
  309:  **         Enables the events.
  310:  **         This method is enabled only if any event is generated.
  311:  **     Parameters  : None
  312:  **     Returns     :
  313:  **         ---             - Error code, possible codes:
  314:  **                           ERR_OK - OK
  315:  **                           ERR_SPEED - This device does not work in
  316:  **                           the active speed mode
  317:  ** ===================================================================
  318:  */
  319:  /*
  320:  byte I2C1_EnableEvent(void)
  321:  
  322:  **  This method is implemented as a macro. See I2C1.h file.  **
  323:  */
  324:  
  325:  /*
  326:  ** ===================================================================
  327:  **     Method      :  I2C1_DisableEvent (bean InternalI2C)
  328:  **
  329:  **     Description :
  330:  **         Disables the events.
  331:  **         This method is enabled only if any event is generated.
  332:  **     Parameters  : None
  333:  **     Returns     :
  334:  **         ---             - Error code, possible codes:
  335:  **                           ERR_OK - OK
  336:  **                           ERR_SPEED - This device does not work in
  337:  **                           the active speed mode
  338:  ** ===================================================================
  339:  */
  340:  /*
  341:  byte I2C1_DisableEvent(void)
  342:  
  343:  **  This method is implemented as a macro. See I2C1.h file.  **
  344:  */
  345:  
  346:  /*
  347:  ** ===================================================================
  348:  **     Method      :  I2C1_SendChar (bean InternalI2C)
  349:  **
  350:  **     Description :
  351:  **         When working as a MASTER, this method writes one (7-bit
  352:  **         addressing) or two (10-bit addressing) slave address
  353:  **         bytes inclusive of R/W bit = 0 to the I2C bus and then
  354:  **         writes one character (byte) to the bus. The slave address
  355:  **         must be specified before, by the "SelectSlave" or
  356:  **         "SelectSlave10" method or in the bean initialization
  357:  **         section, "Target slave address init" property. If
  358:  **         interrupt service is enabled and the method returns
  359:  **         ERR_OK, it doesn't mean that transmission was successful.
  360:  **         The state of transmission is obtainable from
  361:  **         (OnTransmitData, OnError or OnArbitLost) events. 
  362:  **         When working as a SLAVE, this method writes a character
  363:  **         to the internal output slave buffer and, after the master
  364:  **         starts the communication, to the I2C bus. If no character
  365:  **         is ready for a transmission (internal output slave buffer
  366:  **         is empty), the Empty character will be sent (see "Empty
  367:  **         character" property).
  368:  **     Parameters  :
  369:  **         NAME            - DESCRIPTION
  370:  **         Chr             - Character to send.
  371:  **     Returns     :
  372:  **         ---             - Error code, possible codes:
  373:  **                           ERR_OK - OK
  374:  **                           ERR_SPEED - This device does not work in
  375:  **                           the active speed mode
  376:  **                           ERR_DISABLED -  Device is disabled
  377:  **                           ERR_BUSY - The slave device is busy, it
  378:  **                           does not respond by an acknowledge (only
  379:  **                           in master mode and when interrupt
  380:  **                           service is disabled)
  381:  **                           ERR_BUSOFF - Clock timeout elapsed or
  382:  **                           device cannot transmit data
  383:  **                           ERR_TXFULL - Transmitter is full (slave
  384:  **                           mode only)
  385:  **                           ERR_ARBITR - Arbitration lost (only when
  386:  **                           interrupt service is disabled and in
  387:  **                           master mode)
  388:  ** ===================================================================
  389:  */
  390:  unsigned char I2C1_SendChar(unsigned char Chr)
  391:  {
*** EVALUATION ***

Function: I2C1_SendChar
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  0000 37           [2]     PSHB  
  392:    if((IBSR_IBB)||(InpLenM)||(I2C1_SerFlag&(CHAR_IN_TX|WAIT_RX_CHAR|BUSY))) { /* Is the bus busy */
  0001 4e00200a     [4]     BRSET _IBSR,#32,*+14 ;abs = 000f
  0005 fc0000       [3]     LDD   InpLenM
  0008 2605         [3/1]   BNE   *+7 ;abs = 000f
  000a 1f00002604   [5]     BRCLR I2C1_SerFlag,#38,*+9 ;abs = 0013
  393:      return ERR_BUSOFF;                 /* If yes then error */
  000f c601         [1]     LDAB  #1
  0011 2015         [3]     BRA   *+23 ;abs = 0028
  394:    }
  395:    ChrTemp = Chr;                       /* Save character */
  0013 e680         [3]     LDAB  0,SP
  0015 7b0000       [3]     STAB  ChrTemp
  396:    return (I2C1_SendBlock(&ChrTemp, (unsigned short)1, (unsigned short*)&I2C1_SndRcvTemp)); /* Send character and return */
  0018 cc0000       [2]     LDD   #ChrTemp
  001b 3b           [2]     PSHD  
  001c c601         [1]     LDAB  #1
  001e 87           [1]     CLRA  
  001f 3b           [2]     PSHD  
  0020 cc0000       [2]     LDD   #I2C1_SndRcvTemp
  0023 160000       [4]     JSR   I2C1_SendBlock
  0026 1b84         [2]     LEAS  4,SP
  397:  }
  0028 32           [3]     PULA  
  0029 3d           [5]     RTS   
  398:  
  399:  /*
  400:  ** ===================================================================
  401:  **     Method      :  I2C1_RecvChar (bean InternalI2C)
  402:  **
  403:  **     Description :
  404:  **         When working as a MASTER, this method writes one (7-bit
  405:  **         addressing) or two (10-bit addressing) slave address
  406:  **         bytes inclusive of R/W bit = 1 to the I2C bus, then reads
  407:  **         one character (byte) from the bus and then sends the stop
  408:  **         condition. The slave address must be specified before, by
  409:  **         the "SelectSlave" or "SelectSlave10" method or in bean
  410:  **         initialization section, property "Target slave address
  411:  **         init". If interrupt service is enabled and the method
  412:  **         returns ERR_OK, it doesn't mean that transmission was
  413:  **         finished successfully. The state of transmission must be
  414:  **         tested by means of events (OnReceiveData, OnError or
  415:  **         OnArbitLost). In case of successful transmission,
  416:  **         received data is ready after OnReceiveData event is
  417:  **         called. 
  418:  **         When working as a SLAVE, this method reads a character
  419:  **         from the input slave buffer.
  420:  **     Parameters  :
  421:  **         NAME            - DESCRIPTION
  422:  **       * Chr             - Received character.
  423:  **     Returns     :
  424:  **         ---             - Error code, possible codes:
  425:  **                           ERR_OK - OK
  426:  **                           ERR_SPEED - This device does not work in
  427:  **                           the active speed mode
  428:  **                           ERR_DISABLED -  Device is disabled
  429:  **                           ERR_BUSY - The slave device is busy, it
  430:  **                           does not respond by the acknowledge
  431:  **                           (only in master mode and when interrupt
  432:  **                           service is disabled)
  433:  **                           ERR_BUSOFF - Clock timeout elapsed or
  434:  **                           device cannot receive data
  435:  **                           ERR_RXEMPTY - No data in receiver (slave
  436:  **                           mode only)
  437:  **                           ERR_OVERRUN - Overrun error was detected
  438:  **                           from the last character or block
  439:  **                           received (slave mode only)
  440:  **                           ERR_ARBITR - Arbitration lost (only when
  441:  **                           interrupt service is disabled and in
  442:  **                           master mode)
  443:  **                           ERR_NOTAVAIL - Method is not available
  444:  **                           in current mode - see generated code
  445:  **                           comment
  446:  ** ===================================================================
  447:  */
  448:  /*
  449:  byte I2C1_RecvChar(byte *Chr)
  450:  
  451:  **  This method is implemented as a macro. See I2C1.h file.  **
  452:  */
  453:  
  454:  /*
  455:  ** ===================================================================
  456:  **     Method      :  I2C1_SendBlock (bean InternalI2C)
  457:  **
  458:  **     Description :
  459:  **         When working as a MASTER, this method writes one (7-bit
  460:  **         addressing) or two (10-bit addressing) slave address
  461:  **         bytes inclusive of R/W bit = 0 to the I2C bus and then
  462:  **         writes the block of characters to the bus. The slave
  463:  **         address must be specified before, by the "SelectSlave" or
  464:  **         "SlaveSelect10" method or in bean initialization section,
  465:  **         "Target slave address init" property. If interrupt
  466:  **         service is enabled and the method returns ERR_OK, it
  467:  **         doesn't mean that transmission was successful. The state
  468:  **         of transmission is detectable by means of events
  469:  **         (OnTransmitData, OnError or OnArbitLost). Data to be send
  470:  **         is not copied to an internal buffer and remains in the
  471:  **         original location. Therefore the content of the buffer
  472:  **         should not be changed until the transmission is complete.
  473:  **         Event OnTransmitData can be used to detect the end of the
  474:  **         transmission.
  475:  **         When working as a SLAVE, this method writes a block of
  476:  **         characters to the internal output slave buffer and then,
  477:  **         after the master starts the communication, to the I2C bus.
  478:  **         If no character is ready for a transmission (internal
  479:  **         output slave buffer is empty), the "Empty character" will
  480:  **         be sent (see "Empty character" property). In SLAVE mode
  481:  **         the data are copied to an internal buffer, if specified
  482:  **         by "Output buffer size" property.
  483:  **     Parameters  :
  484:  **         NAME            - DESCRIPTION
  485:  **       * Ptr             - Pointer to the block of data to send.
  486:  **         Siz             - Size of the block.
  487:  **       * Snt             - Amount of data sent (moved to a buffer).
  488:  **                           In master mode, if interrupt support is
  489:  **                           enabled, the parameter always returns
  490:  **                           the same value as the parameter 'Siz' of
  491:  **                           this method.
  492:  **     Returns     :
  493:  **         ---             - Error code, possible codes:
  494:  **                           ERR_OK - OK
  495:  **                           ERR_SPEED - This device does not work in
  496:  **                           the active speed mode
  497:  **                           ERR_DISABLED -  Device is disabled
  498:  **                           ERR_BUSY - The slave device is busy, it
  499:  **                           does not respond by the acknowledge
  500:  **                           (only in master mode and when interrupt
  501:  **                           service is disabled)
  502:  **                           ERR_BUSOFF - Clock timeout elapsed or
  503:  **                           device cannot transmit data
  504:  **                           ERR_TXFULL - Transmitter is full. Some
  505:  **                           data has not been sent. (slave mode only)
  506:  **                           ERR_ARBITR - Arbitration lost (only when
  507:  **                           interrupt service is disabled and in
  508:  **                           master mode)
  509:  ** ===================================================================
  510:  */
  511:  unsigned char I2C1_SendBlock(void* Ptr,unsigned short Siz,unsigned short *Snt)
  512:  {
*** EVALUATION ***

Function: I2C1_SendBlock
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  0000 3b           [2]     PSHD  
  513:    if (!Siz) {                          /* Test variable Size on zero */
  0001 ec84         [3]     LDD   4,SP
  0003 2606         [3/1]   BNE   *+8 ;abs = 000b
  514:      *Snt = 0;
  0005 ee80         [3]     LDX   0,SP
  0007 c7           [1]     CLRB  
  0008 87           [1]     CLRA  
  515:      return ERR_OK;                     /* If zero then OK */
  0009 2045         [3]     BRA   *+71 ;abs = 0050
  516:    }
  517:    if(!EnUser) {                        /* Is the device disabled by user? */
  000b f60000       [3]     LDAB  EnUser
  000e 2604         [3/1]   BNE   *+6 ;abs = 0014
  518:      return ERR_DISABLED;               /* If yes then error */
  0010 c603         [1]     LDAB  #3
  0012 203f         [3]     BRA   *+65 ;abs = 0053
  519:    }
  520:    if((IBSR_IBB)||(InpLenM)||(I2C1_SerFlag&(CHAR_IN_TX|WAIT_RX_CHAR|BUSY))) { /* Is the bus busy */
  0014 4e00200a     [4]     BRSET _IBSR,#32,*+14 ;abs = 0022
  0018 fc0000       [3]     LDD   InpLenM
  001b 2605         [3/1]   BNE   *+7 ;abs = 0022
  001d 1f00002604   [5]     BRCLR I2C1_SerFlag,#38,*+9 ;abs = 0026
  521:      return ERR_BUSOFF;                 /* If yes then error */
  0022 c601         [1]     LDAB  #1
  0024 202d         [3]     BRA   *+47 ;abs = 0053
  522:    }
  523:    //EnterCritical();                     /* Enter the critical section */
  524:    asm sei
  0026 1410         [1]     SEI   
  525:    I2C1_SerFlag |= BUSY;                /* Set flag "busy" */
  0028 1c000020     [4]     BSET  I2C1_SerFlag,#32
  526:    OutLenM = Siz;                       /* Set lenght of data */
  002c ec84         [3]     LDD   4,SP
  002e 7c0000       [3]     STD   OutLenM
  527:    OutPtrM = (unsigned char *)Ptr;               /* Save pointer to data for transmitting */
  0031 ec86         [3]     LDD   6,SP
  0033 7c0000       [3]     STD   OutPtrM
  528:    IBCR_TX_RX = 1;                      /* Set TX mode */
  0036 4c0010       [4]     BSET  _IBCR,#16
  529:    if(IBCR_MS_SL) {                     /* Is device in master mode? */
  0039 4f002005     [4]     BRCLR _IBCR,#32,*+9 ;abs = 0042
  530:      IBCR_RSTA = 1;                     /* If yes then repeat start cycle generated */
  003d 4c0004       [4]     BSET  _IBCR,#4
  531:    }
  0040 2003         [3]     BRA   *+5 ;abs = 0045
  532:    else {
  533:      IBCR_MS_SL = 1;                    /* If no then start signal generated */
  0042 4c0020       [4]     BSET  _IBCR,#32
  534:    }
  535:    IBDR = I2C1_SlaveAddr;               /* Send slave address */
  0045 f60000       [3]     LDAB  I2C1_SlaveAddr
  0048 5b00         [2]     STAB  _IBDR
  536:    //ExitCritical();                      /* Exit the critical section */
  537:    asm cli
  004a 10ef         [1]     CLI   
  538:    *Snt = Siz;                          /* Dummy number of really sent chars */
  004c ee80         [3]     LDX   0,SP
  004e ec84         [3]     LDD   4,SP
  0050 6c00         [2]     STD   0,X
  539:    return ERR_OK;                       /* OK */
  0052 c7           [1]     CLRB  
  540:  }
  0053 30           [3]     PULX  
  0054 3d           [5]     RTS   
  541:  
  542:  /*
  543:  ** ===================================================================
  544:  **     Method      :  I2C1_RecvBlock (bean InternalI2C)
  545:  **
  546:  **     Description :
  547:  **         When working as a MASTER, this method writes one (7-bit
  548:  **         addressing) or two (10-bit addressing) slave address
  549:  **         bytes inclusive of R/W bit = 1 to the I2C bus, then reads
  550:  **         the block of characters from the bus and then sends the
  551:  **         stop condition. The slave address must be specified
  552:  **         before, by the "SelectSlave" or "SelectSlave10" method or
  553:  **         in bean initialization section, "Target slave address
  554:  **         init" property. If interrupt service is enabled and the
  555:  **         method returns ERR_OK, it doesn't mean that transmission
  556:  **         was finished successfully. The state of transmission must
  557:  **         be tested by means of events (OnReceiveData, OnError or
  558:  **         OnArbitLost). In case of successful transmission,
  559:  **         received data is ready after OnReceiveData event is
  560:  **         called. 
  561:  **         When working as a SLAVE, this method reads a block of
  562:  **         characters from the input slave buffer.
  563:  **     Parameters  :
  564:  **         NAME            - DESCRIPTION
  565:  **       * Ptr             - A pointer to the block space for
  566:  **                           received data.
  567:  **         Siz             - The size of the block.
  568:  **       * Rcv             - Amount of received data. In master mode,
  569:  **                           if interrupt support is enabled, the
  570:  **                           parameter always returns the same value
  571:  **                           as the parameter 'Siz' of this method.
  572:  **     Returns     :
  573:  **         ---             - Error code, possible codes:
  574:  **                           ERR_OK - OK
  575:  **                           ERR_SPEED - This device does not work in
  576:  **                           the active speed mode
  577:  **                           ERR_DISABLED -  Device is disabled
  578:  **                           ERR_BUSY - The slave device is busy, it
  579:  **                           does not respond by an acknowledge (only
  580:  **                           in master mode and when interrupt
  581:  **                           service is disabled)
  582:  **                           ERR_BUSOFF - Clock timeout elapsed or
  583:  **                           device cannot receive data
  584:  **                           ERR_RXEMPTY - The receive buffer didn't
  585:  **                           contain the requested number of data.
  586:  **                           Only available data (or no data) has
  587:  **                           been returned  (slave mode only).
  588:  **                           ERR_OVERRUN - Overrun error was detected
  589:  **                           from last character or block receiving
  590:  **                           (slave mode only)
  591:  **                           ERR_ARBITR - Arbitration lost (only when
  592:  **                           interrupt service is disabled and in
  593:  **                           master mode)
  594:  ** ===================================================================
  595:  */
  596:  unsigned char I2C1_RecvBlock(void* Ptr,unsigned short Siz,unsigned short *Rcv)
  597:  {
*** EVALUATION ***

Function: I2C1_RecvBlock
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  0000 3b           [2]     PSHD  
  598:    if (!Siz) {                          /* Test variable Size on zero */
  0001 ec84         [3]     LDD   4,SP
  0003 2606         [3/1]   BNE   *+8 ;abs = 000b
  599:      *Rcv = 0;
  0005 ee80         [3]     LDX   0,SP
  0007 c7           [1]     CLRB  
  0008 87           [1]     CLRA  
  600:      return ERR_OK;                     /* If zero then OK */
  0009 2030         [3]     BRA   *+50 ;abs = 003b
  601:    }
  602:    if(!EnUser) {                        /* Is the device disabled by user? */
  000b f60000       [3]     LDAB  EnUser
  000e 2604         [3/1]   BNE   *+6 ;abs = 0014
  603:      return ERR_DISABLED;               /* If yes then error */
  0010 c603         [1]     LDAB  #3
  0012 202a         [3]     BRA   *+44 ;abs = 003e
  604:    }
  605:    //if((IBSR_IBB)||(InpLenM)||(I2C1_SerFlag&(CHAR_IN_TX|WAIT_RX_CHAR|BUSY))) { /* Is the bus busy */
  606:    //  return ERR_BUSOFF;                 /* If yes then error */
  607:    //}
  608:    //EnterCritical();                     /* Enter the critical section */
  609:    asm sei
  0014 1410         [1]     SEI   
  610:    InpLenM = Siz;                       /* Set lenght of data */
  0016 ec84         [3]     LDD   4,SP
  0018 7c0000       [3]     STD   InpLenM
  611:    InpPtrM = (unsigned char *)Ptr;               /* Save pointer to data for reception */
  001b ec86         [3]     LDD   6,SP
  001d 7c0000       [3]     STD   InpPtrM
  612:    IBCR_TX_RX = 1;                      /* Set TX mode */
  0020 4c0010       [4]     BSET  _IBCR,#16
  613:    if(IBCR_MS_SL) {                     /* Is device in master mode? */
  0023 4f002005     [4]     BRCLR _IBCR,#32,*+9 ;abs = 002c
  614:      IBCR_RSTA = 1;                     /* If yes then repeat start cycle generated */
  0027 4c0004       [4]     BSET  _IBCR,#4
  615:    }
  002a 2003         [3]     BRA   *+5 ;abs = 002f
  616:    else {
  617:      IBCR_MS_SL = 1;                    /* If no then start signal generated */
  002c 4c0020       [4]     BSET  _IBCR,#32
  618:    }
  619:    IBDR = (unsigned char)(I2C1_SlaveAddr+1);     /* Send slave address */
  002f f60000       [3]     LDAB  I2C1_SlaveAddr
  0032 52           [1]     INCB  
  0033 5b00         [2]     STAB  _IBDR
  620:    //ExitCritical();                      /* Exit the critical section */
  621:    asm cli
  0035 10ef         [1]     CLI   
  622:    *Rcv = Siz;                          /* Dummy number of really received chars */
  0037 ee80         [3]     LDX   0,SP
  0039 ec84         [3]     LDD   4,SP
  003b 6c00         [2]     STD   0,X
  623:    return ERR_OK;                       /* OK */
  003d c7           [1]     CLRB  
  624:  }
  003e 30           [3]     PULX  
  003f 3d           [5]     RTS   
  625:  
  626:  /*
  627:  ** ===================================================================
  628:  **     Method      :  I2C1_GetCharsInTxBuf (bean InternalI2C)
  629:  **
  630:  **     Description :
  631:  **         Returns number of characters in the output buffer. In
  632:  **         SLAVE mode returns the number of characters in the
  633:  **         internal slave output buffer. In MASTER mode returns
  634:  **         number of characters to be sent from the user buffer
  635:  **         (passed by SendBlock method).
  636:  **         This method is not supported in polling mode.
  637:  **     Parameters  : None
  638:  **     Returns     :
  639:  **         ---             - Number of characters in the output
  640:  **                           buffer.
  641:  ** ===================================================================
  642:  */
  643:  unsigned short I2C1_GetCharsInTxBuf(void)
  644:  {
*** EVALUATION ***

Function: I2C1_GetCharsInTxBuf
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  645:    return(OutLenM);                     /* Return number of chars remaining in the Master Tx buffer */
  0000 fc0000       [3]     LDD   OutLenM
  646:  }
  0003 3d           [5]     RTS   
  647:  
  648:  /*
  649:  ** ===================================================================
  650:  **     Method      :  I2C1_GetCharsInRxBuf (bean InternalI2C)
  651:  **
  652:  **     Description :
  653:  **         Returns number of characters in the input buffer. In
  654:  **         SLAVE mode returns the number of characters in the
  655:  **         internal slave input buffer. In MASTER mode returns
  656:  **         number of characters to be received into a user buffer
  657:  **         (passed by RecvChar or RecvBlock method).
  658:  **         This method is not supported in polling mode.
  659:  **     Parameters  : None
  660:  **     Returns     :
  661:  **         ---             - Number of characters in the input
  662:  **                           buffer.
  663:  ** ===================================================================
  664:  */
  665:  unsigned short I2C1_GetCharsInRxBuf(void)
  666:  {
*** EVALUATION ***

Function: I2C1_GetCharsInRxBuf
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  667:    return(InpLenM);                     /* Return number of chars remaining in the Master Tx buffer */
  0000 fc0000       [3]     LDD   InpLenM
  668:  }
  0003 3d           [5]     RTS   
  669:  
  670:  /*
  671:  ** ===================================================================
  672:  **     Method      :  I2C1_SelectSlave (bean InternalI2C)
  673:  **
  674:  **     Description :
  675:  **         This method selects a new slave for communication by its
  676:  **         7-bit slave address value. Any send or receive method
  677:  **         directs to or from selected device, until a new slave
  678:  **         device is selected by this method. This method is not
  679:  **         available for the SLAVE mode.
  680:  **     Parameters  :
  681:  **         NAME            - DESCRIPTION
  682:  **         Slv             - 7-bit slave address value.
  683:  **     Returns     :
  684:  **         ---             - Error code, possible codes:
  685:  **                           ERR_OK - OK
  686:  **                           ERR_BUSY - The device is busy, wait
  687:  **                           until the current operation is finished.
  688:  **                           ERR_SPEED - This device does not work in
  689:  **                           the active speed mode
  690:  **                           ERR_DISABLED -  The device is disabled
  691:  ** ===================================================================
  692:  */
  693:  unsigned char I2C1_SelectSlave(unsigned char Slv)
  694:  {
*** EVALUATION ***

Function: I2C1_SelectSlave
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  0000 37           [2]     PSHB  
  695:    //LED_redOn();
  696:    if (!EnUser) {                       /* Is the device disabled by user? */
  0001 f60000       [3]     LDAB  EnUser
  0004 2604         [3/1]   BNE   *+6 ;abs = 000a
  697:      return ERR_DISABLED;               /* If yes then error */
  0006 c603         [1]     LDAB  #3
  0008 200f         [3]     BRA   *+17 ;abs = 0019
  698:    }
  699:    if (IBCR_MS_SL == 1) {               /* Is the device in the active state? */
  000a 4f002004     [4]     BRCLR _IBCR,#32,*+8 ;abs = 0012
  700:      return ERR_BUSY;                   /* If yes then error */
  000e c604         [1]     LDAB  #4
  0010 2007         [3]     BRA   *+9 ;abs = 0019
  701:    }
  702:    //LED_greenOn();
  703:    I2C1_SlaveAddr = (unsigned char)(Slv << 1);   /* Set slave address */
  0012 e680         [3]     LDAB  0,SP
  0014 58           [1]     LSLB  
  0015 7b0000       [3]     STAB  I2C1_SlaveAddr
  704:    return ERR_OK;                       /* OK */
  0018 c7           [1]     CLRB  
  705:  }
  0019 32           [3]     PULA  
  001a 3d           [5]     RTS   
  706:  
  707:  /*
  708:  ** ===================================================================
  709:  **     Method      :  I2C1_GetMode (bean InternalI2C)
  710:  **
  711:  **     Description :
  712:  **         This method returns the actual operating mode of this
  713:  **         bean.
  714:  **     Parameters  : None
  715:  **     Returns     :
  716:  **         ---             - Actual operating mode value
  717:  **                           TRUE - Master
  718:  **                           FALSE - Slave
  719:  ** ===================================================================
  720:  */
  721:  /*
  722:  bool I2C1_GetMode(void)
  723:  
  724:  **  This method is implemented as a macro. See I2C1.h file.  **
  725:  */
  726:  
  727:  /*
  728:  ** ===================================================================
  729:  **     Method      :  I2C1_Init (bean InternalI2C)
  730:  **
  731:  **     Description :
  732:  **         Initializes the associated peripheral(s) and the beans 
  733:  **         internal variables. The method is called automatically as a 
  734:  **         part of the application initialization code.
  735:  **         This method is internal. It is used by Processor Expert only.
  736:  ** ===================================================================
  737:  */
  738:  void I2C1_Init(void)
  739:  {
*** EVALUATION ***

Function: I2C1_Init
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  740:    /* IBCR: IBEN=0,IBIE=0,MS_SL=0,TX_RX=0,TXAK=0,RSTA=0,??=0,IBSWAI=0 */
  741:    IBCR = 0;                            /* Clear control register */
  0000 790000       [3]     CLR   _IBCR
  742:    I2C1_SerFlag = 128;                  /* Reset all flags */
  0003 cc0180       [2]     LDD   #384
  0006 7b0000       [3]     STAB  I2C1_SerFlag
  743:    I2C1_EnEvent = 1;                 /* Enable events */
  0009 7a0000       [3]     STAA  I2C1_EnEvent
  744:    EnUser = 1;                       /* Enable device */
  000c 7a0000       [3]     STAA  EnUser
  745:    I2C1_SlaveAddr = 16;                 /* Set variable for slave address */
  000f c610         [1]     LDAB  #16
  0011 7b0000       [3]     STAB  I2C1_SlaveAddr
  746:    /* IBFD: IBC7=0,IBC6=0,IBC5=0,IBC4=1,IBC3=1,IBC2=1,IBC1=1,IBC0=1 */
  747:    IBFD = 31;                           /* Set prescaler bits */
  0014 c61f         [1]     LDAB  #31
  0016 5b00         [2]     STAB  _IBFD
  748:    IBCR_IBEN = 1;                       /* Enable device */
  0018 4c0080       [4]     BSET  _IBCR,#128
  749:    /* IBCR: IBEN=1,IBIE=1,MS_SL=0,TX_RX=0,TXAK=0,RSTA=0,??=0,IBSWAI=0 */
  750:    IBCR = 192;                          /* Control register settings */
  001b c6c0         [1]     LDAB  #192
  001d 5b00         [2]     STAB  _IBCR
  751:    InpLenM = 0;                 
  001f c7           [1]     CLRB  
  0020 87           [1]     CLRA  
  0021 7c0000       [3]     STD   InpLenM
  752:    OutLenM = 0;
  0024 7c0000       [3]     STD   OutLenM
  753:  }
  0027 3d           [5]     RTS   
  754:  
  755:  /*
  756:  ** ===================================================================
  757:  **     Method      :  I2C1_CheckBus (bean InternalI2C)
  758:  **
  759:  **     Description :
  760:  **         This method returns the status of the bus. If the START
  761:  **         condition has been detected, the method returns
  762:  **         'BeanName'_BUSY. If the STOP condition has been detected,
  763:  **         the method returns 'BeanName'_IDLE.
  764:  **     Parameters  : None
  765:  **     Returns     :
  766:  **         ---             - Status of the bus.
  767:  ** ===================================================================
  768:  */
  769:  /*
  770:  byte I2C1_CheckBus(void)
  771:  
  772:  **  This method is implemented as a macro. See I2C1.h file.  **
  773:  */
  774:  
  775:  
  776:  /* END I2C1. */
  777:  
  778:  /*
  779:  ** ###################################################################
  780:  **
  781:  **     This file was created by UNIS Processor Expert 2.99 [04.12]
  782:  **     for the Freescale HCS12 series of microcontrollers.
  783:  **
  784:  ** ###################################################################
  785:  */
  786:  
  787:  
  788:  
  789:  
  790:  
  791:  
  792:  
  793:  
  794:  
  795:  
  796:  
  797:  
  798:  /*********************************events************************/
  799:  
  800:  
  801:  
  802:  
  803:  
  804:  
  805:  
  806:  
  807:  
  808:  void I2C1_OnReceiveData(void){
*** EVALUATION ***

Function: I2C1_OnReceiveData
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  809:    newI2cData = 1;
  0000 c601         [1]     LDAB  #1
  0002 7b0000       [3]     STAB  newI2cData
  810:  }
  0005 3d           [5]     RTS   
  811:  /*
  812:  ** ===================================================================
  813:  **     Event       :  I2C1_OnReceiveData (module Events)
  814:  **
  815:  **     From bean   :  I2C1 [InternalI2C]
  816:  **     Description :
  817:  **         This event is invoked when I2C finishes the reception of
  818:  **         the data successfully. This event is not available for
  819:  **         the SLAVE mode and if both RecvChar and RecvBlock are
  820:  **         disabled. This event is enabled only if interrupts/events
  821:  **         are enabled.
  822:  **     Parameters  : None
  823:  **     Returns     : Nothing
  824:  ** ===================================================================
  825:  */
  826:  
  827:  void I2C1_OnTransmitData(void){
*** EVALUATION ***

Function: I2C1_OnTransmitData
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  828:    I2cTransDone = 1;
  0000 c601         [1]     LDAB  #1
  0002 7b0000       [3]     STAB  I2cTransDone
  829:  }
  0005 3d           [5]     RTS   
  830:  /*
  831:  ** ===================================================================
  832:  **     Event       :  I2C1_OnTransmitData (module Events)
  833:  **
  834:  **     From bean   :  I2C1 [InternalI2C]
  835:  **     Description :
  836:  **         This event is invoked when I2C finishes the transmission
  837:  **         of the data successfully. This event is not available for
  838:  **         the SLAVE mode and if both SendChar and SendBlock are
  839:  **         disabled. This event is enabled only if interrupts/events
  840:  **         are enabled.
  841:  **     Parameters  : None
  842:  **     Returns     : Nothing
  843:  ** ===================================================================
  844:  */
  845:  
  846:  
  847:  void I2C1_OnByteTransfer(void){
*** EVALUATION ***

Function: I2C1_OnByteTransfer
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  848:    
  849:  }
  0000 3d           [5]     RTS   
  850:  /*
  851:  ** ===================================================================
  852:  **     Event       :  I2C1_OnByteTransfer (module Events)
  853:  **
  854:  **     From bean   :  I2C1 [InternalI2C]
  855:  **     Description :
  856:  **         This event is called when one-byte transfer (including
  857:  **         the acknowledge bit) is successfully finished (slave
  858:  **         address or one data byte is transmitted or received).
  859:  **         This event is not available for the SLAVE mode and if all
  860:  **         RecvChar, RecvBlock, SendChar and SendBlock are disabled.
  861:  **         Note: It is possible to use the event for slowing down
  862:  **         communication, when slower slave needs some time for data
  863:  **         processing.
  864:  **     Parameters  : None
  865:  **     Returns     : Nothing
  866:  ** ===================================================================
  867:  */
  868:  
  869:  void I2C1_OnArbitLost(void){
*** EVALUATION ***

Function: I2C1_OnArbitLost
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  870:  }
  0000 3d           [5]     RTS   
  871:  /*
  872:  ** ===================================================================
  873:  **     Event       :  I2C1_OnArbitLost (module Events)
  874:  **
  875:  **     From bean   :  I2C1 [InternalI2C]
  876:  **     Description :
  877:  **         This event is called when the master lost the bus
  878:  **         arbitration or the device detects an error on the bus.
  879:  **         This event is enabled only if interrupts/events are
  880:  **         enabled.
  881:  **     Parameters  : None
  882:  **     Returns     : Nothing
  883:  ** ===================================================================
  884:  */
  885:  
  886:  void I2C1_OnNACK(void){
*** EVALUATION ***

Function: I2C1_OnNACK
Source  : C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources\i2c_master_intr.c
Options : -BfaGapLimitBits-1 -Cc -CPUHCS12 -D__NO_FLOAT__ -D_HCS12_SERIALMON -Env"GENPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\prm;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\cmd;C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Env"TEXTPATH=C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="C:\Documents and Settings\Aaron Landy\Desktop\OC_DP512\OC_DP512_Data\HCS12_Serial_Monitor\ObjectCode\i2c_master_intr.c.o" -WmsgSd1106

  887:  }
  0000 3d           [5]     RTS   
  888:  /*
  889:  ** ===================================================================
  890:  **     Event       :  I2C1_OnNACK (module Events)
  891:  **
  892:  **     From bean   :  I2C1 [InternalI2C]
  893:  **     Description :
  894:  **         Called when a no slave acknowledge (NAK) occurs during
  895:  **         communication. This event is not available for the SLAVE
  896:  **         mode. This event is enabled only if interrupts/events are
  897:  **         enabled.
  898:  **     Parameters  : None
  899:  **     Returns     : Nothing
  900:  ** ===================================================================
  901:  */
  902:  
  903:  
  904:  /*
  905:  ** ###################################################################
  906:  **
  907:  **     This file was created by UNIS Processor Expert 2.99 [04.12]
  908:  **     for the Freescale HCS12 series of microcontrollers.
  909:  **
  910:  ** ###################################################################
  911:  */
  912:  
  913:  
  914:  
  915:  
  916:  
  917:  
  918:  
  919:  
  920:  
  921:  
  922:  
  923:  
  924:  
  925:  
  926:  
  927:  
  928:  
